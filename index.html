<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Number Match Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #f3f4f6;
      --panel: #ffffff;
      --border: #e5e7eb;
      --accent: #2563eb;
      --text-main: #111827;
      --text-muted: #6b7280;
      --right: #16a34a;
      --wrong: #dc2626;
      --card-bg: #ffffff;
      --button-bg: #f9fafb;
      --button-border: #d1d5db;
    }

    body.dark-mode {
      --bg: #0f172a;
      --panel: #020617;
      --border: #1f2937;
      --accent: #38bdf8;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --right: #4ade80;
      --wrong: #f97373;
      --card-bg: #1e293b;
      --button-bg: #0b1120;
      --button-border: #1f2937;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      padding: 12px;
      transition: background-color 0.15s, color 0.15s;
    }

    #game {
      width: 100%;
      max-width: 480px;
      margin: auto;
      background: var(--panel);
      border-radius: 16px;
      border: 1px solid var(--border);
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.15);
      padding: 14px 12px 16px;
    }

    #top-bar {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }

    h1 {
      margin: 0;
      font-size: 1.4rem;
      letter-spacing: 0.02em;
    }

    #theme-toggle {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--button-border);
      background: var(--button-bg);
      color: var(--text-main);
      font-size: 0.78rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
    }

    #theme-toggle:active { transform: translateY(1px); }

    #setup-screen { margin-top: 8px; }

    #settings {
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .setting-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .setting-label {
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 0.68rem;
      color: var(--text-muted);
    }

    #settings label {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #settings input[type="number"] {
      flex: 1;
      min-width: 0;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--button-bg);
      color: var(--text-main);
      font-size: 0.9rem;
    }

    #btn-start {
      margin-top: 10px;
      width: 100%;
      padding: 10px 14px;
      border-radius: 999px;
      border: none;
      background: var(--accent);
      color: #fff;
      font-weight: 600;
      font-size: 0.95rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      cursor: pointer;
    }

    #btn-start:active { transform: translateY(1px); }

    #session-stats {
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    #game-screen {
      margin-top: 8px;
      display: none;
    }

    #card-area {
      margin: 14px 0 8px;
      position: relative;
      height: 120px;
    }

    #rule-overlay {
      position: absolute;
      inset: 0;
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2;
    }

    .card-box {
      width: 100%;
      padding: 22px 14px 18px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--card-bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      min-height: 110px;
    }

    #rule-overlay .card-box {
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
    }

    #rule-overlay-label {
      text-transform: uppercase;
      letter-spacing: 0.16em;
      font-size: 0.7rem;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    #rule-overlay-text {
      font-size: 1.4rem;
      font-weight: 600;
      color: var(--accent);
    }

    #rule-overlay-round {
      margin-top: 6px;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    #stim-card {
      position: absolute;
      inset: 0;
      font-size: 2rem;
      font-weight: 600;
      z-index: 1;
    }

    #status-row {
      margin-top: 4px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px 8px;
      align-items: center;
      justify-content: space-between;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    #score {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    #score strong { color: var(--accent); }

    #accuracy, #round { font-variant-numeric: tabular-nums; }

    #feedback {
      margin-top: 6px;
      min-height: 1.2em;
      font-size: 0.9rem;
      font-weight: 600;
      text-align: center;
    }

    #feedback.correct { color: var(--right); }
    #feedback.incorrect { color: var(--wrong); }
    #feedback .neutral-stats { color: var(--text-main); font-weight: 400; }

    #buttons {
      display: flex;
      gap: 10px;
      margin: 18px 0 8px;
    }

    #buttons button {
      flex: 1;
      padding: 14px 16px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 1rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      cursor: pointer;
      background: var(--button-bg);
      color: var(--text-main);
    }

    #btn-same {
      background: linear-gradient(135deg, var(--accent), #22c55e);
      color: #0b1120;
      border-color: transparent;
    }

    #buttons button:active { transform: translateY(1px); }
    button:disabled { opacity: 0.45; cursor: default; }

    #btn-home {
      margin-top: 32px;
      width: 100%;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--button-border);
      background: var(--button-bg);
      color: var(--text-main);
      font-size: 0.9rem;
      cursor: pointer;
    }

    #btn-home:active { transform: translateY(1px); }

    @media (min-width: 640px) {
      #game { padding: 16px 16px 18px; }
      #stim-card { font-size: 2.4rem; }
    }
  </style>
</head>
<body>
  <div id="game">
    <div id="top-bar">
      <h1>Number Match</h1>
      <button id="theme-toggle" type="button">Dark mode</button>
    </div>

    <div id="setup-screen">
      <div id="settings">
        <div class="setting-group">
          <span class="setting-label">Round time</span>
          <label>
            <input id="input-round-time" type="number" min="100" max="600000" step="100" value="1300">
            <span>ms</span>
          </label>
        </div>
        <div class="setting-group">
          <span class="setting-label">Rounds</span>
          <label>
            <input id="input-rounds" type="number" min="1" max="9999" step="10" value="20">
          </label>
        </div>
        <div class="setting-group">
          <span class="setting-label">Values</span>
          <label>min <input id="input-min" type="number" min="1" max="3999" value="1"></label>
          <label>max <input id="input-max" type="number" min="1" max="3999" value="20"></label>
        </div>
      </div>
      <div id="session-stats"></div>
      <button id="btn-start" type="button">Start</button>
    </div>

    <div id="game-screen">
      <div id="card-area">
        <div id="stim-card" class="card-box"></div>
        <div id="rule-overlay">
          <div class="card-box">
            <span id="rule-overlay-label">Rule</span>
            <span id="rule-overlay-text"></span>
            <span id="rule-overlay-round"></span>
          </div>
        </div>
      </div>

      <div id="status-row">
        <div id="score">
          <span>Score: <strong id="score-value">0</strong></span>
          <span id="accuracy">(0 / 0)</span>
        </div>
        <div id="round">Round 0 / 0</div>
      </div>

      <div id="feedback"></div>

      <div id="buttons">
        <button id="btn-same" type="button">Same</button>
        <button id="btn-different" type="button">Different</button>
      </div>

      <button id="btn-home" type="button">Back to Home</button>
    </div>
  </div>

  <script>
    const MAX_VALUE = 3999;
    const RULE_PREVIEW_MS = 1000;
    const SETTINGS_KEY = "nm-settings-v1";

    const ROMAN_NUMERALS = [
      ["M", 1000], ["CM", 900], ["D", 500], ["CD", 400],
      ["C", 100], ["XC", 90], ["L", 50], ["XL", 40],
      ["X", 10], ["IX", 9], ["V", 5], ["IV", 4], ["I", 1]
    ];

    const EN_UNDER_20 = [
      "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine",
      "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen",
      "seventeen", "eighteen", "nineteen"
    ];

    const EN_TENS = ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"];

    function toRoman(n) {
      if (n <= 0 || n > MAX_VALUE) return null;
      let result = "", value = n;
      for (const [sym, val] of ROMAN_NUMERALS) {
        while (value >= val) {
          result += sym;
          value -= val;
        }
      }
      return result;
    }

    function toEnglish(n) {
      if (n < 0 || n > 9999) return null;
      if (n < 20) return EN_UNDER_20[n];
      if (n < 100) {
        const rest = n % 10;
        return rest ? `${EN_TENS[n / 10 | 0]}-${EN_UNDER_20[rest]}` : EN_TENS[n / 10 | 0];
      }
      if (n < 1000) {
        const rest = n % 100;
        const base = `${EN_UNDER_20[n / 100 | 0]} hundred`;
        return rest ? `${base} ${toEnglish(rest)}` : base;
      }
      const rest = n % 1000;
      const base = `${toEnglish(n / 1000 | 0)} thousand`;
      return rest ? `${base} ${toEnglish(rest)}` : base;
    }

    function buildRepresentations(min, max) {
      const reps = [];
      for (let v = min; v <= max; v++) {
        reps.push({ value: v, text: String(v), system: "Arabic" });
        const roman = toRoman(v);
        if (roman) reps.push({ value: v, text: roman, system: "Roman" });
        const english = toEnglish(v);
        if (english) reps.push({ value: v, text: english, system: "English" });
      }
      return reps;
    }

    const $ = id => document.getElementById(id);
    const body = document.body;
    const setupScreen = $("setup-screen");
    const gameScreen = $("game-screen");
    const roundTimeInput = $("input-round-time");
    const roundsInput = $("input-rounds");
    const minValueInput = $("input-min");
    const maxValueInput = $("input-max");
    const stimCardEl = $("stim-card");
    const btnSame = $("btn-same");
    const btnDifferent = $("btn-different");
    const scoreValueEl = $("score-value");
    const accuracyEl = $("accuracy");
    const feedbackEl = $("feedback");
    const roundEl = $("round");
    const ruleOverlay = $("rule-overlay");
    const ruleOverlayText = $("rule-overlay-text");
    const ruleOverlayRound = $("rule-overlay-round");
    const sessionStatsEl = $("session-stats");
    const themeToggleBtn = $("theme-toggle");

    let config = { roundTimeMs: 1300, rounds: 20, minValue: 1, maxValue: 20 };
    let state = {
      representations: [],
      currentPair: null,
      currentRule: "value",
      score: 0,
      totalTrials: 0,
      currentRound: 0,
      locked: true,
      trialStartTime: null,
      sessionRTs: [],
      roundTimerId: null,
      roundEndAt: 0,
      preRoundTimeoutId: null
    };

    function applyTheme(mode) {
      body.classList.toggle("dark-mode", mode === "dark");
      themeToggleBtn.textContent = mode === "dark" ? "Light mode" : "Dark mode";
      try { localStorage.setItem("nm-theme", mode); } catch (e) {}
    }

    (function initTheme() {
      try { applyTheme(localStorage.getItem("nm-theme") === "dark" ? "dark" : "light"); } catch (e) { applyTheme("light"); }
    })();

    themeToggleBtn.addEventListener("click", () => {
      applyTheme(body.classList.contains("dark-mode") ? "light" : "dark");
    });

    function loadSettings() {
      try {
        const s = JSON.parse(localStorage.getItem(SETTINGS_KEY));
        if (s) {
          if (s.roundTimeMs) roundTimeInput.value = s.roundTimeMs;
          if (s.rounds) roundsInput.value = s.rounds;
          if (s.min) minValueInput.value = s.min;
          if (s.max) maxValueInput.value = s.max;
        }
      } catch (e) {}
    }

    function saveSettings() {
      try {
        localStorage.setItem(SETTINGS_KEY, JSON.stringify({
          roundTimeMs: config.roundTimeMs, rounds: config.rounds,
          min: config.minValue, max: config.maxValue
        }));
      } catch (e) {}
    }

    loadSettings();

    function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

    function pickRandomPair() {
      const pool = state.representations;
      if (pool.length < 2) return null;
      const i = Math.random() * pool.length | 0;
      let j;
      do { j = Math.random() * pool.length | 0; } while (j === i);
      return [pool[i], pool[j]];
    }

    function clearTimers() {
      if (state.roundTimerId) { clearInterval(state.roundTimerId); state.roundTimerId = null; }
      if (state.preRoundTimeoutId) { clearTimeout(state.preRoundTimeoutId); state.preRoundTimeoutId = null; }
    }

    function setButtonsEnabled(enabled) {
      btnSame.disabled = btnDifferent.disabled = !enabled;
      state.locked = !enabled;
    }

    function updateScoreboard() {
      scoreValueEl.textContent = state.score;
      accuracyEl.textContent = `(${state.score} / ${state.totalTrials})`;
      roundEl.textContent = `Round ${state.currentRound} / ${config.rounds}`;
    }

    function getAverageRT() {
      if (!state.sessionRTs.length) return null;
      return Math.round(state.sessionRTs.reduce((a, b) => a + b, 0) / state.sessionRTs.length);
    }

    function updateHomeStats() {
      const avg = getAverageRT();
      sessionStatsEl.textContent = avg != null ? `Last session average: ${avg} ms` : "";
    }

    function startTimer() {
      state.roundEndAt = Date.now() + config.roundTimeMs;
      state.roundTimerId = setInterval(() => {
        if (Date.now() >= state.roundEndAt) {
          clearInterval(state.roundTimerId);
          state.roundTimerId = null;
          handleTimeUp();
        }
      }, 100);
    }

    function handleTimeUp() {
      if (state.locked || !state.currentPair) return;
      state.locked = true;
      state.totalTrials++;
      updateScoreboard();
      finishTrial();
    }

    function showRuleOverlay(nextRound) {
      state.currentRule = Math.random() < 0.5 ? "value" : "category";
      ruleOverlayText.textContent = state.currentRule === "value" ? "Same VALUE?" : "Same CATEGORY?";
      ruleOverlayRound.textContent = `Round ${nextRound} of ${config.rounds}`;
      ruleOverlay.style.display = "flex";
    }

    function hideRuleOverlay() {
      ruleOverlay.style.display = "none";
    }

    function newRound() {
      feedbackEl.textContent = "";
      feedbackEl.className = "";

      if (state.currentRound >= config.rounds) { endGame(); return; }

      clearTimers();
      state.currentPair = null;
      setButtonsEnabled(false);

      showRuleOverlay(state.currentRound + 1);
      state.preRoundTimeoutId = setTimeout(startRoundAfterPreview, RULE_PREVIEW_MS);
    }

    function startRoundAfterPreview() {
      state.preRoundTimeoutId = null;

      const pair = pickRandomPair();
      if (!pair) {
        hideRuleOverlay();
        stimCardEl.textContent = "?";
        feedbackEl.textContent = "No valid numbers in this range.";
        feedbackEl.className = "incorrect";
        return;
      }

      state.currentPair = pair;
      state.currentRound++;
      state.trialStartTime = Date.now();

      // Set content BEFORE hiding overlay
      stimCardEl.textContent = `${pair[0].text} - ${pair[1].text}`;
      hideRuleOverlay();

      updateScoreboard();
      setButtonsEnabled(true);
      startTimer();
    }

    function finishTrial() {
      if (state.currentRound >= config.rounds) endGame();
      else setTimeout(newRound, 700);
    }

    function endGame() {
      clearTimers();
      hideRuleOverlay();
      setButtonsEnabled(false);
      roundEl.textContent = `Round ${state.currentRound} / ${config.rounds} (done)`;

      const avg = getAverageRT();
      let html = feedbackEl.textContent.trim();
      html = html ? html + " Session complete." : "Session complete.";
      if (avg != null) html += `<span class="neutral-stats"> Average: ${avg} ms</span>`;
      feedbackEl.innerHTML = html;

      updateHomeStats();
    }

    function handleAnswer(userThinksSame) {
      if (state.locked || !state.currentPair) return;
      setButtonsEnabled(false);
      clearTimers();

      const [left, right] = state.currentPair;
      const actualSame = state.currentRule === "value"
        ? left.value === right.value
        : left.system === right.system;

      state.totalTrials++;

      if (state.trialStartTime != null) {
        state.sessionRTs.push(Date.now() - state.trialStartTime);
        state.trialStartTime = null;
      }

      const correct = userThinksSame === actualSame;
      if (correct) {
        state.score++;
        feedbackEl.textContent = "Correct!";
        feedbackEl.className = "correct";
      } else {
        const sameText = state.currentRule === "value" ? "value" : "category";
        const isSame = state.currentRule === "value" ? left.value === right.value : left.system === right.system;
        feedbackEl.textContent = `Incorrect â€“ They are ${isSame ? "" : "not "}the same ${sameText}.`;
        feedbackEl.className = "incorrect";
      }

      updateScoreboard();
      finishTrial();
    }

    function readConfig() {
      let t = parseInt(roundTimeInput.value, 10) || 1300;
      config.roundTimeMs = clamp(t, 100, 600000);
      roundTimeInput.value = config.roundTimeMs;

      let r = parseInt(roundsInput.value, 10) || 20;
      config.rounds = clamp(r, 1, 9999);
      roundsInput.value = config.rounds;

      let min = parseInt(minValueInput.value, 10) || 1;
      let max = parseInt(maxValueInput.value, 10) || 20;
      if (min > max) [min, max] = [max, min];
      config.minValue = clamp(min, 1, MAX_VALUE);
      config.maxValue = clamp(max, 1, MAX_VALUE);
      minValueInput.value = config.minValue;
      maxValueInput.value = config.maxValue;

      state.representations = buildRepresentations(config.minValue, config.maxValue);
      saveSettings();
    }

    function startSession() {
      readConfig();
      Object.assign(state, {
        score: 0,
        totalTrials: 0,
        currentRound: 0,
        currentPair: null,
        trialStartTime: null,
        sessionRTs: []
      });
      feedbackEl.textContent = "";
      feedbackEl.className = "";
      stimCardEl.textContent = "";
      updateScoreboard();
      setupScreen.style.display = "none";
      gameScreen.style.display = "block";
      newRound();
    }

    function returnToSetup() {
      clearTimers();
      hideRuleOverlay();
      setButtonsEnabled(false);
      updateHomeStats();
      setupScreen.style.display = "block";
      gameScreen.style.display = "none";
    }

    $("btn-start").addEventListener("click", startSession);
    btnSame.addEventListener("click", () => handleAnswer(true));
    btnDifferent.addEventListener("click", () => handleAnswer(false));
    $("btn-home").addEventListener("click", returnToSetup);
  </script>
</body>
</html>
